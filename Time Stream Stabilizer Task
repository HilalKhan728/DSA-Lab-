#include <iostream>
#include <string>
#include <limits> // This Header file is used to usefuly handle strem input in console (Non-integers)
#include <algorithm> // Used for Sorting,Searching and finding Max,Min ( Although min,max are manually implemented but using it is convention)

using namespace std;

// =========================================================
// 1. THE NODE: A Single Time Capsule
// =========================================================
struct TimeCapsule {
    int year;               // Key
    string eventName;       // Data
    TimeCapsule* left;      // Left Child (Earlier years)
    TimeCapsule* right;     // Right Child (Later years)

    // Constructor for easy node creation
    TimeCapsule(int y, string n) : year(y), eventName(n), left(nullptr), right(nullptr) {}
};

// =========================================================
// 2. THE BST CLASS: Chronos Time Tree
// =========================================================
class TimeTree {
private:
    TimeCapsule* root;

    // --- PRIVATE RECURSIVE HELPERS ---

    // Helper for finding the minimum year in a subtree (Inorder Successor logic)
    TimeCapsule* findMin(TimeCapsule* node) {
        TimeCapsule* current = node;
        while (current && current->left != nullptr) {
            current = current->left;
        }
        return current;
    }

    // TASK 1 Helper: Inserts a new TimeCapsule recursively
    TimeCapsule* insertHelper(TimeCapsule* node, int year, string name) {
        if (node == nullptr) {
            cout << "Timeline stable." << endl;
            return new TimeCapsule(year, name);
        }

        // Check for Duplicates (Uniqueness rule)
        if (year == node->year) {
            cout << "Year already exists. Injection failed (Temporal Duplication)." << endl;
            return node; 
        }

        // Recurse down (Chronological Order and Future Progression)
        if (year < node->year) {
            node->left = insertHelper(node->left, year, name);
        } else { // year > node->year
            node->right = insertHelper(node->right, year, name);
        }

        return node;
    }

    // TASK 2 Helper: Deletes a TimeCapsule recursively
    TimeCapsule* deleteHelper(TimeCapsule* node, int year) {
        // Base Case: Node not found
        if (node == nullptr) {
            cout << "> System: Year " << year << " not found in timeline." << endl;
            return nullptr;
        }

        // 1. Recurse to find the node
        if (year < node->year) {
            node->left = deleteHelper(node->left, year);
        } else if (year > node->year) {
            node->right = deleteHelper(node->right, year);
        } else {
            // Node found! Execute deletion based on cases:
            
            // Case 1: Node with only one child or no child (Leaf Node)
            if (node->left == nullptr) {
                TimeCapsule* temp = node->right;
                delete node;
                // Modified success message to match the expected output
                cout << "> System: Year " << year << " removed. Timeline stabilized." << endl;
                return temp;
            } else if (node->right == nullptr) {
                TimeCapsule* temp = node->left;
                delete node;
                // Modified success message to match the expected output
                cout << "> System: Year " << year << " removed. Timeline stabilized." << endl;
                return temp;
            }

            // Case 2: Node with two children
            // Find the Inorder Successor (smallest in the right subtree)
            TimeCapsule* temp = findMin(node->right);

            // Copy the successor's content to this node
            node->year = temp->year;
            node->eventName = temp->eventName;

            // Delete the Inorder Successor from the right subtree
            // The success message will be printed during this recursive call
            node->right = deleteHelper(node->right, temp->year);
        }
        return node;
    }

    // TASK 3 Helper: Searches for a TimeCapsule
    TimeCapsule* searchHelper(TimeCapsule* node, int year) {
        if (node == nullptr || node->year == year) {
            return node;
        }

        if (year < node->year) {
            return searchHelper(node->left, year);
        } else {
            return searchHelper(node->right, year);
        }
    }

    // TASK 4 Helper: Performs Inorder Traversal (Left -> Root -> Right)
    void reportHelper(TimeCapsule* node) {
        if (node == nullptr) {
            return;
        }

        // 1. Left Subtree (Chronologically Earlier)
        reportHelper(node->left);

        // 2. Root (Current Event) - Using the exact required format
        cout << node->year << ": " << node->eventName << endl;

        // 3. Right Subtree (Chronologically Later)
        reportHelper(node->right);
    }

    // Helper to find the maximum year in the tree
    TimeCapsule* findMax(TimeCapsule* node) {
        TimeCapsule* current = node;
        while (current && current->right != nullptr) {
            current = current->right;
        }
        return current;
    }

    // Helper to clear memory
    void destroyTree(TimeCapsule* node) {
        if (node) {
            destroyTree(node->left);
            destroyTree(node->right);
            delete node;
        }
    }

public:
    TimeTree() { root = nullptr; }
    
    ~TimeTree() { destroyTree(root); }

    // ---------------------------------------------------------
    // TASK 1: INJECT (Insert)
    // ---------------------------------------------------------
    void inject(int year, string name) {
        cout << "> System: Injecting " << year << "... ";
        root = insertHelper(root, year, name);
    }

    // ---------------------------------------------------------
    // TASK 2: PARADOX (Delete)
    // ---------------------------------------------------------
    void resolveParadox(int year) {
        cout << "> Alert: Paradox detected at " << year << "!" << endl;
        if (root == nullptr) {
             cout << "> System: Year " << year << " not found in timeline." << endl;
             return;
        }
        root = deleteHelper(root, year);
    }

    // ---------------------------------------------------------
    // TASK 3: SEARCH
    // ---------------------------------------------------------
    void search(int year) {
        cout << "> Query: Searching for " << year << "..." << endl;
        
        TimeCapsule* result = searchHelper(root, year);
        
        if (result != nullptr) {
             // Exact required format
             cout << "> Result: Event Found! [" << result->year << ": " << result->eventName << "]" << endl;
        } else {
             // Adjusted output based on the expected output's style
             cout << "> Result: Year " << year << " not found in current timeline." << endl;
        }
    }

    // ---------------------------------------------------------
    // TASK 4: REPORT (In-Order Traversal)
    // ---------------------------------------------------------
    void report() {
        cout << "> COMMAND: CHRONOLOGICAL REPORT" << endl;
        cout << "-------------------------------" << endl;
        
        if (root == nullptr) {
            cout << "Timeline is empty. Existential crisis imminent." << endl;
        } else {
            reportHelper(root);
        }
        
        cout << "-------------------------------" << endl;
    }

    // ---------------------------------------------------------
    //  TIME SPAN 
    // ---------------------------------------------------------
    void calculateTimeSpan() {
        cout << "> COMMAND: CALCULATE TIME SPAN" << endl;
        if (root == nullptr) {
            cout << "> Result: Timeline is empty. Span is 0." << endl;
            return;
        }

        TimeCapsule* minNode = findMin(root);
        TimeCapsule* maxNode = findMax(root);

        int minYear = minNode->year;
        int maxYear = maxNode->year;
        int span = maxYear - minYear;

        cout << "> Analysis: Earliest Event: " << minYear << endl;
        cout << "> Analysis: Latest Event: " << maxYear << endl;
        cout << "> Result: Total Time Span is " << span << " years." << endl;
    }
};

// =========================================================
// 3. MAIN INTERFACE (Do not modify input parsing)
// =========================================================
int main() {
    TimeTree chronos;
    string command;
    int year;
    string eventName;

    // Introduction
    cout << "--- CHRONOS TIME STABILIZER V1.0 ---" << endl;
    cout << "Waiting for Time Stream Inputs..." << endl << endl;

    // Command Loop
    while (cin >> command) {
        if (command == "INJECT") {
            cin >> year;
            // getline reads the rest of the line, including spaces
            getline(cin >> ws, eventName); 
            chronos.inject(year, eventName);
        }
        else if (command == "PARADOX") {
            cin >> year;
            chronos.resolveParadox(year);
        }
        else if (command == "SEARCH") {
            cin >> year;
            chronos.search(year);
        }
        else if (command == "REPORT") {
            chronos.report();
        }
        else if (command == "SPAN") {
            chronos.calculateTimeSpan();
        }
        else if (command == "EXIT") {
            cout << "--- Time Agent: System Shutdown. Timeline stability secured. ---" << endl;
            break;
        }
        else {
            cout << "> Unknown Command." << endl;
            // Clear buffer to prevent infinite loops on bad input
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
        cout << endl; // Spacing between commands
    }

    return 0;
}
